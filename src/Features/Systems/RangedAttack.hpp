#pragma once

#include <algorithm>
#include <cmath>
#include <random>
#include <vector>

#include "Core/World.hpp"
#include "Core/Systems/Spatial.hpp"
#include "Features/Domain/Health.hpp"
#include "Features/Domain/Ranged.hpp"
#include "Features/Domain/PoisonAbility.hpp"
#include "Features/Events/UnitAbilityUsed.hpp"
#include "Features/Systems/Damage.hpp"
#include "Features/Systems/Effects.hpp"
#include "Features/Systems/Effects/PoisonEffect.hpp"

namespace sw::features::systems
{
    class RangedAttack
    {
    public:
        static void processUnit(core::World& world, uint32_t attackerId)
        {
            if (!world.restrictions.isAllowed(attackerId, core::registry::restrictions::ATTACK))
            {
                return;
            }

            auto& healthMap = world.getComponent<domain::Health>();
            auto& rangedMap = world.getComponent<domain::Ranged>();

            if (healthMap.find(attackerId) == healthMap.end() ||
                rangedMap.find(attackerId) == rangedMap.end() ||
                healthMap[attackerId].hp == 0)
            {
                return;
            }

            auto attackerPos = world.positions[attackerId];

            std::vector<uint32_t> neighbors;
            core::systems::Spatial::findTargets(world, attackerId, attackerPos, neighbors);
            for (uint32_t id : neighbors)
            {
                if (healthMap.count(id) && healthMap[id].hp > 0)
                {
                    return;
                }
            }

            std::vector<uint32_t> targets;
            for (const auto& [targetId, targetPos] : world.positions)
            {
                if (targetId == attackerId) continue;
                if (!healthMap.count(targetId) || healthMap[targetId].hp == 0) continue;

                uint32_t dist = chebyshevDistance(attackerPos, targetPos);
                if (dist >= 2 && dist <= rangedMap[attackerId].range)
                {
                    targets.push_back(targetId);
                }
            }

            if (targets.empty())
            {
                return;
            }

            static std::random_device rd;
            static std::mt19937 gen(rd());
            std::uniform_int_distribution<size_t> targetDistribution(0, targets.size() - 1);
            uint32_t targetId = targets[targetDistribution(gen)];

            world.restrictions.modify(attackerId, core::registry::restrictions::MOVE, 1);
            world.restrictions.modify(attackerId, core::registry::restrictions::ATTACK, 1);
            executeAttack(world, attackerId, targetId);
        }

    private:
        static void executeAttack(core::World& world, uint32_t attackerId, uint32_t targetId)
        {
            static std::random_device rd;
            static std::mt19937 gen(rd());
            static std::uniform_int_distribution<> dis(1, 1000);

            auto& ranged = world.getComponent<domain::Ranged>()[attackerId];
            auto& poisonAbilities = world.getComponent<domain::PoisonAbility>();

            uint32_t damage = ranged.agility;
            if (auto ability = poisonAbilities.find(attackerId); ability != poisonAbilities.end())
            {
                if (dis(gen) <= ability->second.chance)
                {
                    Effects::addEffect(world, targetId, effects::PoisonEffect::create(attackerId, ability->second.poison));
                    world.getEvents().event(world.getTick(), events::UnitAbilityUsed{attackerId, "poison"});

                    // As poison substitutes the main damage of the attack
                    damage = ability->second.poison / 5;
                }
            }

            if (damage > 0)
            {
                Damage::apply(world, attackerId, targetId, damage);
            }
            //Damage::apply(world, attackerId, targetId, ranged.agility);
        }

        static uint32_t chebyshevDistance(core::Position lhs, core::Position rhs)
        {
            auto dx = std::abs(static_cast<int>(lhs.x) - static_cast<int>(rhs.x));
            auto dy = std::abs(static_cast<int>(lhs.y) - static_cast<int>(rhs.y));
            return static_cast<uint32_t>(std::max(dx, dy));
        }
    };
}