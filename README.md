# Тестовое задание
Перед вами прототип пошаговой боевой системы с юнитами на клеточной карте.
Необходимо спроектировать **расширяемую архитектуру** и продемонстрировать её гибкость, добавив нового юнита с уникальными механиками.

## Правила симуляции
- Карта представляет собой прямоугольную сетку размером W×H клеток.
- Каждый юнит имеет уникальный целочисленный идентификатор.
- Один ход соответствует одному действию одного юнита.
- Юниты действуют в порядке их создания.
- Некоторые юниты могут перемещаться:
  - за один ход юнит может перейти в любую из 8 соседних клеток, если она свободна;
  - если цель недостижима за один ход, юнит продолжает движение к ней в последующих ходах.
- Некоторые юниты могут атаковать, уменьшая количество HP у цели:
  - при достижении 0 HP юнит умирает;
  - после смерти юнит больше не действует и освобождает занимаемую клетку.
- Симуляция завершается, когда не остаётся юнитов, способных совершать действия.

## Существующая реализация
При запуске приложение получает путь к файлу со сценарием симуляции.
Сценарий содержит команды для создания карты, юнитов и их перемещения.

Прототип содержит реализацию одного игрового юнита — мечника.

### Мечник
- **Ближняя атака**: атакует случайного юнита в соседней клетке, нанося урон, равный `Strength`.
- **Способность**: с вероятностью `Chance / 1000` вместо обычной атаки применяет «Рваные раны», нанося `Rending` урона.
- **Поведение**: если цель для атаки отсутствует, перемещается.

## Задача
Спроектировать и реализовать расширяемую архитектуру, затем продемонстрировать ее работу на примере нового юнита.

### Охотник
- **Дальняя атака**: стреляет в случайного юнита на расстоянии от 2 до `Range` клеток, нанося урон, равный `Agility`. Атака возможна только при отсутствии других юнитов в соседних клетках.
- **Ближняя атака**: если дальняя атака невозможна, атакует случайного юнита в соседней клетке, нанося урон, равный `Strength`.
- **Способность**: с вероятностью `Chance / 1000` вместо обычной дальней атаки применяет отравленные стрелы, нанося в сумме `Poison` урона за пять ходов.
  Урон от яда удваивается в тот ход, когда отравленный юнит получает эффект «Рваные раны».
- Урон от яда засчитывается как урон охотника, наложившего эффект.
- **Поведение**: если цель для атаки отсутствует, перемещается.

Формат входных и выходных данных изменять нельзя. 
Событие атаки должно содержать суммарный урон, который нанес один юнит другому. 
Все остальное — на ваше усмотрение. Вы можете не сохранять текущий код из папки Game.

Спроектируйте архитектуру, которая позволит легко добавлять новые сущности и механики взаимодействия. 
Представьте, что над проектом одновременно работают 20 джуниор-разработчиков — каждый добавляет юнитов с уникальными способностями.

Разделите свой код на две папки: `Core` и `Features`.
В `Core` — движок симуляции, в `Features` — реализация конкретных механик мечника и охотника.

Не беспокойтесь о производительности или многопоточности.

## Планы

При разработке учитывайте планы по добавлению новых юнитов, действий и характеристик.
Эта функциональность **не входит** в задание — она лишь указывает направление.

### Маг
- **Дальняя атака**: стреляет в случайного юнита на расстоянии от 2 до `Range` клеток, нанося урон, равный `Spirit`.
- **Способность**: с вероятностью `Chance / 1000` призывает огненную стену из 3 клеток на 5 ходов. Стена не блокирует движение и наносит `Firewall` урона за ход каждому юниту, находящемуся на ней.
- **Поведение**: если цель для атаки отсутствует, перемещается.

### Башня
- **Дальняя атака**: стреляет в случайного юнита на расстоянии от 2 до `Range` клеток, нанося урон, равный `Power`.
- **Поведение**: не перемещается, неуязвима, занимает 2×2 клетки.

### Ворон
- **Летающий юнит**:
  - Не занимает клетку на карте.
  - Может перемещаться на 2 клетки за ход.
  - Не может быть атакован в ближнем бою.
  - Минимальная и максимальная дистанция дальней атаки на ворона снижена на 1.
- **Ближняя атака**: атакует случайного юнита в соседней клетке, нанося `Strength` урона.
- **Поведение**: если цель для атаки отсутствует, перемещается.

## Требования
- Система сборки CMake (проект должен содержать файл CMakeLists.txt).
- Опубликуйте задание в любом публичном Git-репозитории (GitHub, Bitbucket и т. д.).

_Примечание: Если какой-то аспект механики не описан в задании, реализуйте его на свое усмотрение._

Если у вас возникнут вопросы при выполнении задания, присылайте их.

-----------------------------------------------------------------------------------------------
*** Решение

Изначально рассматривал два варианта реализации симуляции: через ECS  и через Очередь Событий. Решил выбрать первый вариант.

1. Обновляем cmake для копирования ресурсов к собранному исполняемому файлу, упрощаем запуск, при необходимости облегчается архивирование для передачи вовне.
2. Настраиваем интеграционные тесты (мы хотим быть уверены, что изменения в коде, о которых задача, не сломают дефолтную модель). Нюанс: в сценариях меням шанс на 0%, чтобы иметь детерминированную модель, но это уменьшает покрытие (некритично сейчас). Настраиваем ci для github, чтобы ПРы были отвалидированы перед мерджем (важно для работы агентов). Ошибка: необходим был второй сет тестов с шансом 100% (но там другая ловушка вылезет).
3. Рефакторинг с разделением на Кор и Фичи, итеративный поиск нужной архитектуры. В итоге принято решение, что Позиция и Движение являются концептуальными понятиями Кора и они были втянуты именно туда. Идея в том, что Мир не существует без этих понятий, хотя отдельные юниты вполне могут быть сделаны и без Позиции/Движения.
4. Ближе к финальным стадиям рефакторинга и после появления расширяемых Систем, для их взаимодействия начала оформляться система Ограничений, которая позволила бы создать расширяемое и независимое взаимодействие между системами (особенно позволяет влиять на Кор новыми расширениями из Фич). При этом Кор у нас не монолит, который нельзя трогать, а всего лишь фундамент с "физическими законами". Если новая система из Фич потребует изменений в этих законах, то мы сперва введём их в Коре, а потом позволим ими управлять всем акторам.
5. Добавление системы Боя (всё ещё рефакторинг), где опять проявилась проблема расширяемости. Была решена через самую настоящую систему Компонент, центральным репозиторием которой является Мир.
6. Всё заработало, симуляция запустилась, и тут нам на помощь пришли те самые интеграционные тесты, которые показали критическую проблему (на одном из тиков Юнит ходил вместо атаки другого Юнита, сделавшего шаг в этом же тике и приблизившегося на радиус атаки).
7. Проблема была решена. Суть заключалась в том, что в Системах обрабатывали Юнитов пачками за проход, а надо было делать по ТЗ — брать Юнита и прогонять по всем Системам за раз. Собрали, получилось, но на первом интеграционном тесте вылезла деталь: после Атаки атакуемый Юнит умирал на следующий тик, а изначальный код был спроектирован так, что смерть наступала прямо там, после Атаки. Это то самое место, где я мог бы сходить и обсудить с гейм-дизайнерами эту тонкость, но такой привелегии нет, поэтому было понятие Системы было разбито на два — Поюнитовая и Глобальная. Цепочка может быть выстроена со стороны игрового клиента, что позволит реализовать и текущую логику, и что-нибудь, действующее глобально на всех, допустим, в середине апдейта.
8. Все интеграционные тесты прошли, кроме последнего, где нам и надо реализовать Охотника. При пропуске, как в старой логике, вылезла ещё логическая цепочка, которую легко обошли добавление Смерти для каждого юнита в начале поюнитового прохода.
9. Полноценное введение Охотника, для чего система Атаки была разделена на Ближнюю и Дальнюю (а Абилити выделена пока отдельно), Охотник научился делать Ближние и Дальние Атаки, Ходить; переписан последний интеграционный тест под новую схему.
10. Тут уже начинает не хватать именно цепочки команд, которая бы выстраивалась нашей логикой на тике, видоизменялась компонентами, а потом исполнялась. Это решило бы типичные геймплейные фичи пошаговых игр: изменение очерёдности, выкидывание действий, откаты. А также упростило бы многие системы, логика которых основывается на происходящем в этом ходу. Решено было не реализовывать в связи с недостатком времени.
11. Реализована система эффектов. Охотник работает.
12. Валидация результатов с ТЗ: оказывается, не все механики изначально работали корректно! Прогнал на изначальном коде с шансом Способностей 100%, проанализовал лог и нашёл расхождение с ТЗ.
13. Дополнительным слоем обнаружил свою же ошибку: 100 в сценарии означает лишь 10% шанса. Невнимательно изучил ТЗ. Правим сценарии и эталонные логи.
14. Борьба с Эффектами и Дальней Атакой, чтобы получить лог согласно ТЗ. Вылазят проблем вида "наносят урон одновременно и Выстрел и Яд", "Яд стакается" и так далее (последнее оставили).

Итог:
А. Не все механики реализованы корректно.
Б. Не идеально разделены Core/Features, есть связность.
В. Решение расширяемо, но чувствительно к контролю порядка.
Г. Стоило попробовать POC для решения с Очередью Событий.

Альтернатива с Очередью Событий:
a. Отделяем принятие решений по изменению от фактического изменения состояния Мира.
b. Видна вся картина, легко выполняем любые логические операции над цепочками.